; ======================================================================================================
;  '||   ||` '||`   ||                                 /.\      '||`
;   ||   ||   ||    ||     ''                         // \\      ||   ''
;   ||   ||   ||  ''||''   ||  '||),,(|,   '''|.     //...\\     ||   ||   '''|.  `||''|,  '''/  '''|.
;   ||   ||   ||    ||     ||   || || ||  .|''||    //     \\    ||   ||  .|''||   ||  ||   //  .|''||
;   `|...|'  .||.   `|..' .||. .||    ||. `|..||. .//       \\. .||. .||. `|..||. .||  ||. /... `|..||.
; =====================================================================================================
;
; Script Name:  Domar en Yew
;
;                           ;
;         ;               ~~`~~      ;
;        ~`~             ~~`~~`~    `~`
;       ~~`~~           `~~~`~~~~  `~`~`   ,
;      ~~`~~`~           ~`~~~`~   `~`~`"_/O\""\
;    ~`~~`~~`~~~        ~~~`~~~`~   ~|`~_ |[|##|
;     `~~`~~~`~          ~~~|~~~`      '_--...__
;      ~`~|~\_~\_   __/¯¯)  |     _- _-  _       _
;         |   |/     .'( )  |              _- _-  _
;         |  / -\   __`/\ \ |_- _- ¯_  -
;      _____/ /--'(^,__ /\ \     //\       _
;    /'  GM   \      | |  \ \    ||\\_- _-  _
;     \....( /       ;;;___;;;  /||~~`~~
;      ||   \\          | |   _/ ||~~~`~~~ -
;      \\    \\         |=|  /_( ||~~`~~~`      _
;       \\_   \\_    , (__|    _  ~~~~`~~~_- _-  _
;   _- _-  _   -   <`_\ __; _-  _  ~~~`~~
;    _   -    _   -  (_ __)     _    ~~;~~     -_
;       _- _-  _    < / < \  _-  _    -     _-   _
;
set %version v1.8
;
; *** NOTAS "MÁGICAS" ^^ *** :
; - Si la macro de domar se os para en un determinado sitio y el pj no se mueve, pausad la macro,
;   abrid una nueva pestaña en el EasyUO, y escribid lo siguiente: set *posicion 0
;   Le dais al play una vez, y otra al stop. Una vez hecho esto, volver a encender la macro de domar.
;
; MEJORAS :
; - Añadido un "sub" para comer cada cierto tiempo hasta quedar saciado.
; - Añadido un "sub" para activar el modo "always run" para que vaya corriendo por el mapa en lugar de ir andando.
; - Añadido el "sub" pathFind para moverse (Author: ScriptFellow).
; - Añadida un "sub" para evitar que el PJ entre a domar animales en zonas que están bugeadas (Ejem: 493,803,-3 ). Si detectáis otras locations que dan problemas, avisadme por Discord para que las incluya en la macro.
; - Añadida opción de subir la habilidad de "Ocultarse".
;-------------------------------------------------------
set %tiempo_alimentacion 360 ; Cada cuántos segundos va a comprobar si tiene hambre (6 minutos).
set %ignore_locs_X 316_340_418_456_488_492_530
set %ignore_locs_Y 1066_936_836_833_809_804_806
set %ignore_locs_Z -4_-3
set %tiempo_actual #SCNT ; Reloj
set %proxima_vez #SCNT ; Trigger
set %comida RGG_NRD_QSD_ZBG_WLI_QRD_END_FUD_YLI_WLI_HGI
     +_KGI_EGI_QLI_KLI_MLI_KRD_HQD_AQD_MQE_VQE_TQE_JQE_IQE
     +_GQE_SPE_ZPE_OQE_BDF_KPE_RQE_YSD_SQD_YWI_AXI_PQD_QQD
;
; ********* MACRO *********
;
set #SYSMSGCOl 88
event SysMessage TammingGenius by Nilaween
event SysMessage [ MOD+ Sthil %version ]
set #SYSMSGCOl 43
event SysMessage Intentando acudir a la ultima posicion. Por favor, ayudame a llegar.
chooseskill Anim real
ignoreitem *bloqueados
gosub comprobar_comida
gosub choose_pace run ; Lo primero, cambiar el modo de moverse a "correr".
gosub setupHid
goto movimiento

INICIO:
set *posicion *posicion + 1
gosub hiding

nuevotarget:
set %fail 0
set %intentos 3
set %distancia 19
set %tiempo_actual #SCNT
if %proxima_vez <= %tiempo_actual ; Comer cada cierto tiempo si hay hambre
{
  gosub comprobar_comida
}
set #LTARGETID N/A
finditem * G_25
for #FINDINDEX 1 #FINDCNT
{
if #FINDREP <> 3 2
ignoreitem #FINDID IGNORE_ANIMALS
set *bloqueados *bloqueados , _ , #FINDID
if #FINDREP = 3 && #FINDID notIn %recientameados && #FINDDIST < %distancia && #FINDX < 755 2
set %tmp_animal #FINDID
set %distancia #FINDDIST
}
if %tmp_animal = #CHARID
goto movimiento
event PROPERTY %tmp_animal
if ( OSO in #PROPERTY && #SKILL < 601 ) || SERPIENTE in #PROPERTY || HORRENDO in #PROPERTY 2
set %recientameados %recientameados , _ , %tmp_animal
goto nuevotarget
gosub checkBugTarget
repitiendotarget:
set %jstart #jindex
event macro 13 35
target
set #LTARGETID %tmp_animal
set #LTARGETKIND 1
event macro 22
gosub wait_for MSG TE_ACEPTA TU_HABILIDAD YA_ESTA NO_PUEDE_SER NO_PUEDES_DOMAR GET_THERE NO_PUEDES_VER SEE_THE_TARGET UNEXPECTED_TARGET FUERA_DE_TU ESTAS_DEMASIADO_LEJOS NO_CONSIGUES 200
if ( #TRUE in #RESULT )
     {
       if TE_ACEPTA in #RESULT || TU_HABILIDAD in #RESULT || %fail > 5 3
          {
            event macro 1 0 all release
            gosub hiding
            set %recientameados %recientameados , _ , %tmp_animal
            goto nuevotarget
          }
       if YA_ESTA in #RESULT || NO_PUEDE_SER in #RESULT || NO_PUEDES_DOMAR in #RESULT || GET_THERE in #RESULT || %intentos <= 0 3
          {
            set *bloqueados *bloqueados , _ , %tmp_animal
            ignoreitem %tmp_animal IGNORE_ANIMALS
            gosub hiding
            goto nuevotarget
          }
       if SEE_THE_TARGET in #RESULT
          {
            goto nuevotarget
          }
       if NO_PUEDES_VER in #RESULT || UNEXPECTED_TARGET in #RESULT || FUERA_DE_TU in #RESULT
          {
            set %fail %fail + 1
            gosub seguir
            gosub hiding
            goto repitiendotarget
          }
       if ESTAS_DEMASIADO_LEJOS in #RESULT
          {
            gosub seguir
            gosub hiding
            goto repitiendotarget
          }
       if NO_CONSIGUES in #RESULT
          {
            set %intentos %intentos + 1
            gosub hiding
          }
     }
goto repitiendotarget

;=====================================================
; Rutina para, en caso de hambre, comer hasta saciarse
;=====================================================
; v2.2
sub comprobar_comida
{
  hambriento:
  set %jrnl #jindex ; Marcamos un índice de las líneas del diario.
  event macro 4 0 .hungry
  wait 20
  while #true
     {
       if #jindex > %jrnl ; Si aparece una nueva línea.
          {
            set %jrnl %jrnl + 1  ; Seleccionamos ese numero de línea.
            scanjournal %jrnl   ; La leemos...
            if Dentro_de_1_minuto in #journal
               {
                 wait 120s ; Save del server...
               }
            if Estas_no_le_afecta_el_hambre in #journal || Estas_tan_lleno_que_no_puedes in #journal || Estas_totalmente_saciado in #journal
               {
                 set %proxima_vez %tiempo_actual + %tiempo_alimentacion
                 return
               }
               else
                  {
                    if Estas_lleno in #journal || Estas_contento in #journal || Estas_en_inanicion in #journal || Estas_hambriento in #journal || Sientes_mucho in #journal || Estas_con_hambre in #journal || Estas_parcialmente in #journal || Estas_bien_lleno in #journal || Te_sientes_casi_lleno in #journal
                       {
                         finditem %comida C_ , #backpackid
                         if #findcnt > 0
                            {
                              set #lobjectid #findid
                              event macro 17
                              wait 20
                              goto hambriento
                            }
                            else
                               {
                                 event exmsg #charid 3 48 COMPRA COMIDA!!
                                 wait 40
                                 set %proxima_vez %tiempo_actual + %tiempo_alimentacion
                               }
                       }
                       else ; Mensaje extraño, repetimos...
                          {
                            goto hambriento
                          }
                  }
          }
       return
     } ; FIN While
}
return

sub setupHid ; <==============================>
display yesno ********************** [ HIDING ] **********************$$
            + ¿Quieres intentar OCULTAR tu PJ mientras macreas?       $$
            + ******************************************************* $$
if ( #dispres = yes )
     {
       set %hiding #TRUE
     }
     else
        {
          set %hiding #FALSE
        }
return

sub hiding ; <==============================>
if ( %hiding )
     {
       if ( H Notin #CHARSTATUS )
            {
              event macro 13 21 ; Use skill Hiding
              gosub waitForSysVar CHARSTATUS = H 55
            }
     }
return

sub checkBugTarget ; <==============================>
finditem %tmp_animal
if #FINDX In %ignore_locs_X && #FINDY In %ignore_locs_Y && #FINDZ In %ignore_locs_Z ; El animal está en una parte del mapa (Yew) bugeado, y el PJ se queda atrapado.
   {
     set *bloqueados *bloqueados , _ , #FINDID
     ignoreitem #FINDID ANIMAL_BUGEADO
     set #SYSMSGCOL 38
     event sysmessage IGNORANDO ANIMAL! :-(
     wait 20
     goto nuevotarget
   }
   else ; Podemos acercarnos al bicho sin que nos quedemos flapados... :P
      {
        gosub pathFind #FINDX #FINDY #FINDZ 1 5
      }
return

sub seguir ; <==============================>
if %tiempopathfind > #SYSTIME && %tiempopathfind <> N/A
return
set %tiempopathfind #SYSTIME + 2000
finditem %tmp_animal
if #FINDKIND <> -1 && #FINDDIST > 4
gosub pathFind #FINDX #FINDY #FINDZ 1 5
return

MOVIMIENTO:
set %nuevaronda 1
goto *posicion
0:
move 636 866
set * . #TIME #TIME
goto INICIO
1:
move 646 915
goto INICIO
2:
move 568 919
goto INICIO
3:
move 547 875
goto INICIO
4:
move 510 838
goto INICIO
5:
move 450 860
goto INICIO
6:
move 439 894
goto INICIO
7:
move 366 957
goto INICIO
8:
move 306 1000
goto INICIO
9:
move 343 1030
goto INICIO
10:
move 408 1024
goto INICIO
11:
move 491 963
goto INICIO
12:
move 536 984
goto INICIO
13:
move 514 1065
goto INICIO
14:
move 484 1102
goto INICIO
15:
move 506 1153
goto INICIO
16:
move 538 1130
goto INICIO
17:
move 552 1065
goto INICIO
18:
move 576 1037
goto INICIO
19:
move 615 1017
goto INICIO
20:
move 636 963
goto INICIO
21:
move 602 934
goto INICIO
22:
move 682 907
move 721 925
set *posicion -1
deletevar recientameados
goto INICIO

;-@ ============================== @-;
;-@ ############################## @-;
;-@ SUBS públicos del Foro EasyUO  @-;
;-@ ############################## @-;
;-@ ============================== @-;
;
;===========================================================
; Name: pathFind
; Author: ScriptFellow (the.WZA)
; Parameters: %1 = X
;             %2 = Y
;             %3 = Z
;             %4 = tolerance
;             %5 = timeout (in seconds)
; Purpose: Pathfind to the given coordinates
; Return: %return (#true or #false )
;-----------------------------------------------------------
sub pathFind
set %_x %1
set %_y %2
if %0 <= 2 || %2 = N/A
   set %_z -1
else
   set %_z %3
if %0 <= 3 || %3 = N/A
   set %_tolerance 0
else
   set %_tolerance %4
if %0 <= 4
   set %_endTime #sCnt + 15
else
   set %_endTime #sCnt + %5
set %return #false
deleteJournal
scanJournal 2
event PathFind %_x %_y %_z
_pathFindScanAgain:
scanJournal 1
if pathfinding in #journal
   goto _pathFindOkay
if can't_get_there in #journal || #sCnt > %_endTime
   return
goto _pathFindScanAgain
_pathFindOkay:
gosub _pathFindDist %_x %_y %_z #charPosX #charPosY #charPosZ
set %return %return <= %_tolerance
if %return
{
   if %_tolerance > 0
   {
      set %1 #cliLeft + #cliXRes / 2
      set %2 #cliTop + #cliYRes / 2
      if #charDir < 3
          set %1 %1 + 1
      else
      {
         if #charDir > 3 && #charDir < 7
            set %1 %1 - 1
      }
      if #charDir = 0 || #charDir = 6
         set %2 %2 - 1
      else
      {
         if #charDir > 1 && #charDir < 5
            set %2 %2 + 1
      }
      click %1 %2 R
   }
   return
}
if #sCnt > %_endTime
   return
goto _pathFindOkay

sub _pathFindDist
set %1 %1 - %4 abs
set %2 %2 - %5 abs
set %3 %3 - %6 abs
gosub max %1 %2 %3
return

; to be defined
sub max
set %return %1
for %_idx 2 %0
{
   if % . %_idx > %return
   set %return % . %_idx
}
return
;=================================================================
sub wait_for
;=================================================================
; This "wait_for" sub package was created by Locke. If you use these subs please keep this header intact.
; Documentation: the sub package grew to large with all the comments. To load them call the sub like this:
; gosub wait_for docs    | or you can use doc, documention, what, or my personal favorite, kickass.

; "wait_for core dispatcher" version 1.2 by Locke
if %1 = doc || if %1 = docs || if %1 = documentation || if %1 = what || if %1 = kickass
{
Display ok Please click ok and wait for your browser to start.
execute http://www.easyuo.com/forum/viewtopic.php?t=24716
halt
}
nameSpace Push
namespace local LLNS
set #result N/A ; if #result isn't set by one of my wait_for subs it'll throw an error.
set !LPC #lpc
set #lpc 200
for %i 0 %0
set !_A . %i % . %i
gosub wait_for_ , !_A1
set #lpc !lpc
namespace clear LLNS
namespace pop
if #result <> N/A
return #result
else
display ok You specified an unknown wait_for command. Script returned #result and is halting.
halt
;=================================================================
sub wait_for_MSG ; version 1.4 ~Locke
;=================================================================
if !_A0 < 3
{
display ok You haven't specified enough vars.$
+The basic format is: gosub wait_for MSG %message time_out_in_seconds$
+Script is halting
halt
}
set !_timeout ( #scnt2 + !_A . !_A0 )
_lets_wait_for_a_message:
for %i %jstart #jindex
{
 scanjournal %i
  for %ii 2 !_A0
  {
    if !_A . %ii in #journal && %jstart <> %i
    set #result #true , #spc , !_A . %ii
  }
}

if #true notin #result
{
set #result #false
 if !_timeout =< #scnt2
 return #result
wait 1
goto _lets_wait_for_a_message
}
else
return #result

wait 1
goto _lets_wait_for_a_message
;==================================
; Script Name: Peragrins' Pace choosing sub
; Author: Peragrin
; Version: v1.1
; Client Tested with: 4.0.10b
; EUO version tested with: 1.42.00A5
; Shard OSI / FS: OSI
; Revision Date: 05/06/05
; Public Release: 22/09/04
; Purpose: callable subroutine to pick whether always run is on or off
; Revisions: v1.1 now uses Namespace and better journal scanning
;============================================
sub choose_pace
;%0 - 1
;%1 - WALK/RUN
if %0 <> 1 || %1 notin WALK_RUN
        {
        display OK Incorrect arguments passed to ChoosePace subroutine, script halted.
        halt
        }
namespace push
namespace LOCAL ChoosePace
set !desired_pace %1
_TOGGLE_PACE:
set !jindex #jindex + 1
event macro 32 0
_CHOOSE_PACE_JOURNAL_SCAN:
gosub ScanJournal ALWAYS_RUN !jindex 1
if #result
        {
           if ON in #journal && !desired_pace = WALK
                goto _toggle_pace
           if OFF in #journal && !desired_pace = RUN
                goto _toggle_pace
        }
if ! #result
        {
        set !error !error + 1
        if !error > 5
                {
                   set !error 0
                   goto _toggle_pace
                }
        goto _choose_pace_journal_scan
        }
return
;==================================
; Script Name: Peragrins' journal scanning sub
; Author: Peragrin
; Version: v1.0
; Client Tested with: 4.0.10b
; EUO version tested with: 1.42.00A5
; Shard OSI / FS: OSI
; Revision Date: 05/06/05
; Public Release: 22/09/04
; Purpose: callable subroutine to scan for phrases passed to the sub
;============================================
sub scanJournal
;%0 - 2
;%1 - phrase to scan for
;%2 - #jindex to scan from
;%3 - time to scan for
namespace push
namespace local ScanJournal
for !timeout 1 %3
        {
        for !line %2 #jindex
                {
                scanjournal !line
                wait 1
                if %1 in #journal
                        {
                        namespace pop
                        return #true
                        }
                }
        wait 1s
        }
namespace pop
return #false
;=======================================
sub waitForSysVar
if %0 < 4 || %4 = N/A
set %4 %_defaultWaitForTimeout
if %0 < 5
set %5 return
set %4 #sCnt2 + %4
_waitForSysVar:
set % . %5 # . %1 %2 %3
if ! % . %5 && #sCnt2 < %4
{
Wait 1
goto _waitForSysVar
}
return
;=======================================
